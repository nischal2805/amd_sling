const express = require('express');
const { PlatformConnection } = require('../models');
const auth = require('../middleware/auth');

const router = express.Router();

// GET /api/connections
router.get('/', auth, async (req, res, next) => {
  try {
    const connections = await PlatformConnection.findAll({
      where: { user_id: req.user.id },
      attributes: { exclude: ['access_token', 'refresh_token'] }
    });
    res.json(connections);
  } catch (err) {
    next(err);
  }
});

// GET /api/connections/:platform/auth
router.get('/:platform/auth', auth, async (req, res, next) => {
  try {
    const { platform } = req.params;

    let url;
    if (platform === 'youtube') {
      const youtube = require('../services/youtube');
      url = youtube.getAuthUrl();
    } else if (platform === 'instagram') {
      const instagram = require('../services/instagram');
      url = instagram.getAuthUrl();
    } else if (platform === 'linkedin') {
      const linkedin = require('../services/linkedin');
      url = linkedin.getAuthUrl();
    } else if (platform === 'twitter') {
      const twitter = require('../services/twitter');
      const result = await twitter.getAuthUrl();
      // Store codeVerifier temporarily in the connection record or session
      await PlatformConnection.upsert({
        user_id: req.user.id,
        platform: 'twitter_pending',
        access_token: result.codeVerifier,
        additional_data: { state: result.state, userId: req.user.id }
      });
      return res.json({ url: result.url });
    } else {
      return res.status(400).json({ error: 'Unsupported platform' });
    }

    res.json({ url });
  } catch (err) {
    next(err);
  }
});

// GET /api/connections/:platform/callback
router.get('/:platform/callback', async (req, res, next) => {
  try {
    const { platform } = req.params;
    const { code, state, error } = req.query;

    if (error) return res.redirect(`${process.env.FRONTEND_URL}/connections?error=${error}`);

    // For Twitter, state is auto-generated by the library, not the userId
    // For other platforms, state contains the userId
    let userId;

    if (platform === 'twitter') {
      // Twitter: state is auto-generated by twitter-api-v2, not the userId
      const allPending = await PlatformConnection.findAll({ where: { platform: 'twitter_pending' } });
      const pending = allPending.find(p => p.additional_data?.state === state);
      if (!pending) return res.redirect(`${process.env.FRONTEND_URL}/connections?error=no_verifier`);
      userId = pending.additional_data.userId || pending.user_id;

      const twitter = require('../services/twitter');
      const tokens = await twitter.exchangeCode(code, pending.access_token);
      await PlatformConnection.upsert({
        user_id: userId,
        platform: 'twitter',
        access_token: tokens.accessToken,
        refresh_token: tokens.refreshToken,
        is_active: true
      });
      await pending.destroy();
    } else if (platform === 'youtube') {
      userId = state;
      const { google } = require('googleapis');
      const oauth2Client = new google.auth.OAuth2(
        process.env.YOUTUBE_CLIENT_ID,
        process.env.YOUTUBE_CLIENT_SECRET,
        process.env.YOUTUBE_REDIRECT_URI
      );
      const { tokens } = await oauth2Client.getToken(code);
      await PlatformConnection.upsert({
        user_id: userId,
        platform: 'youtube',
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        token_expires_at: tokens.expiry_date ? new Date(tokens.expiry_date) : null,
        is_active: true
      });
    } else if (platform === 'instagram') {
      userId = state;
      const instagram = require('../services/instagram');
      const tokenData = await instagram.exchangeCode(code);
      const igUserId = await instagram.getInstagramUserId(tokenData.access_token);
      await PlatformConnection.upsert({
        user_id: userId,
        platform: 'instagram',
        access_token: tokenData.access_token,
        instagram_user_id: igUserId,
        is_active: true
      });
    } else if (platform === 'linkedin') {
      userId = state;
      const linkedin = require('../services/linkedin');
      const tokenData = await linkedin.exchangeCode(code);
      const profile = await linkedin.getProfile(tokenData.access_token);
      await PlatformConnection.upsert({
        user_id: userId,
        platform: 'linkedin',
        access_token: tokenData.access_token,
        platform_user_id: profile.sub,
        platform_username: profile.name,
        platform_email: profile.email,
        is_active: true
      });
    }

    res.redirect(`${process.env.FRONTEND_URL}/connections?connected=${platform}`);
  } catch (err) {
    next(err);
  }
});

// DELETE /api/connections/:platform
router.delete('/:platform', auth, async (req, res, next) => {
  try {
    const conn = await PlatformConnection.findOne({
      where: { user_id: req.user.id, platform: req.params.platform }
    });
    if (!conn) return res.status(404).json({ error: 'Connection not found' });

    await conn.destroy();
    res.json({ message: `${req.params.platform} disconnected` });
  } catch (err) {
    next(err);
  }
});

module.exports = router;
